# Javascript deep dive
> TIL from Javascript deep dive

- Chapter01: What is programming?
  - computational thinking
  - machine code(bit unit) <-compiler or interpreter -> programming language
  -programming language = syntax + semantics
- Chapter02: What is Javascript?
  - complier, link and build
- Chapter03: Environment of Javascript
- Chapter04: Variable
  - When are variables declared and assigned?
  - What is hoisting?
- Chapter05: Expression and Statement
  - value, expression, evaluate
- Chapter06: Data type
  - Why we need the data types?
  - Primitive and object/reference type
  - What is difference of immutable and mutable?
- Chapter07: Operator
- Chapter08: Control flow statement
  - Conditional statement
    - What is fall through in switch statement?
  - loop statement
    - What situations should we use the for or while?
    - What is label statement?
- Chapter09: Type casting
  - Explicit coercion and Implicit coercion
  - Truthy and falsy value in javascript
  - Short-circuit evaluation
  - Optional chaining `?.`
  - null coalescing `??`
- Chapter10: Object literal
  - Property and Method
- Chapter11: Primitive type and Object/reference type
  - Mutable and immutable value
  - What is pass by value and pass by reference?
  - What is array like object?
  - What is shallow copy and deep copy
- Chapter12: Function
  - Argument, Parameter, Return value
  - Functions are called by identifier, not by function name
  - Javascript function is the first class object
  - What is different between function declaration and function literal?
  - Arrow function(ES6)
  - Recursive function
  - What is callback function and higher-order function?
  - Pure and impure function
- Chapter13: Scope
  - Identifier resolution
  - Lexical environment and Execution context
  - Scope is name space
  - Scope chain
  - Lexical scope and dynamic scope
    - The upper scope of a function is determined by where it is defined.
- Chapter14: The problem of global variable
  - Life cycle of variable
  - Implicit coupling
  - Namespace object
  - Module patterns
- Chapter15: let, const keyword and block level scope
  - What is TDZ?
  - Why we use const or let for declare the variable than var?
- Chapter16: Property attribute
  - Inner slot and inner method `[[...]]`
  - Property attribute and property descriptor(`getOwnPropertyDescriptor(object,property)`)
  - Data property and accessor property
  - Prevent object changes
  - Immutable object by recursion
- Chapter17: Constructor
  - What is constructor and instance?
  - How to make instance?
  - What is this in object?
  - Why the constructor doesn't have return value?
  - When the `[[new]]` and `[[construct]]` are called?
  - What is differ between `construct` and `non-construct`?
  - `new.target`
  - Scope-safe constructor
- Chapter18: Function and First-class object
  - Property of function object
  - Arguments
  - Prototype property
  - Caller, length, name, property
- Chapter19: Prototype
  - Property and attribute and abstraction
  - Inheritance
  - Prototype Object, `[[prototype]]`
  - `__proto__`
  - Prototype property of function object
  - Prototype chain and `Object.prototype`
  - Scope chain and prototype chain
  - Overriding, property shadowing and overloading
  - Change of prototype
  - `instanceof` operator
  - Static methods and prototype methods
  - The dangers of `in` and `for...in` syntax
- Chapter20: Strict mode
  - Implicit global
  - Errors in strict mode
- Chapter21: Built-in Objects
  - Primary value and Wrapper object
  - Global object(`window in  browser` or `global in node`)
  - `globalThis`
  - `eval`
  - `encodeURI / decodeURI`
- Chapter22: this
  - `this`: self-referencing variable
  - `this binding`
  - Difference between this and lexical scope
- Chapter23: Execution Context
  - Source code type
  - Source code evaluation and execution
    - [Lexical environment](https://ko.javascript.info/closure#ref-1178)
    - [Lexical environment and closure](https://ko.javascript.info/closure)
  - Scope, identifier and code execution order managed by execution context
  - `Lexical environment` and `execution context stack`(`call stack`)
    - `execution context` = `lexical environment` + `variable environment`
    - - Difference Between Function Hoisting and Variable Hoisting
  - Generate of execution context and identifier searching process
  - Global code evaluation process
    - generate the global execution context
    - generate the lexical environment
    - this binding
    - determining References to External Lexical Environments
      - identifier resolution
- Chapter24: Closure
  - `scope` === `lexical environment of execution context`
  - Free variable in closure
  - Encapsulation and information hiding